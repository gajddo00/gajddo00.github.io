"use strict";
exports.id = 534;
exports.ids = [534];
exports.modules = {

/***/ 2855:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "xq": () => (/* binding */ AdminApi),
  "z9": () => (/* binding */ AuthApi),
  "Hi": () => (/* binding */ AuthMethod),
  "GL": () => (/* binding */ LoginHistoryFilter),
  "uU": () => (/* binding */ Role),
  "R0": () => (/* binding */ ServiceState),
  "UW": () => (/* binding */ ServiceType),
  "x0": () => (/* binding */ ServicesApi),
  "x3": () => (/* binding */ ServicesManagerApi),
  "Wj": () => (/* binding */ UserApi)
});

// UNUSED EXPORTS: AdminApiAxiosParamCreator, AdminApiFactory, AdminApiFp, AuthApiAxiosParamCreator, AuthApiFactory, AuthApiFp, NotificationsApi, NotificationsApiAxiosParamCreator, NotificationsApiFactory, NotificationsApiFp, ServicesApiAxiosParamCreator, ServicesApiFactory, ServicesApiFp, ServicesManagerApiAxiosParamCreator, ServicesManagerApiFactory, ServicesManagerApiFp, UserApiAxiosParamCreator, UserApiFactory, UserApiFp, UsersApi, UsersApiAxiosParamCreator, UsersApiFactory, UsersApiFp

// EXTERNAL MODULE: external "axios"
var external_axios_ = __webpack_require__(2167);
var external_axios_default = /*#__PURE__*/__webpack_require__.n(external_axios_);
;// CONCATENATED MODULE: ./api/configuration.ts
class Configuration {
    constructor(param = {}){
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.baseOptions = param.baseOptions;
        this.formDataCtor = param.formDataCtor;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */ isJsonMime(mime) {
        const jsonMime = new RegExp("^(application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(;.*)?$", "i");
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === "application/json-patch+json");
    }
}

;// CONCATENATED MODULE: ./api/base.ts
/* tslint:disable */ /* eslint-disable */ /**
 * SSO.Api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ 
// Some imports not used depending on template conditions
// @ts-ignore

const base_BASE_PATH = "https://7897-217-170-104-228.ngrok.io".replace(/\/+$/, "");
/**
 *
 * @export
 */ const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "	",
    pipes: "|"
};
/**
 *
 * @export
 * @class BaseAPI
 */ class base_BaseAPI {
    constructor(configuration, basePath = base_BASE_PATH, axios = (external_axios_default())){
        this.basePath = basePath;
        this.axios = axios;
        if (!configuration) {
            configuration = new Configuration();
        }
        this.configuration = configuration;
        this.basePath = configuration.basePath || this.basePath;
    }
}
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */ class RequiredError extends Error {
    constructor(field, msg){
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}

;// CONCATENATED MODULE: ./api/common.ts

/**
 *
 * @export
 */ const common_DUMMY_BASE_URL = "https://example.com";
/**
 *
 * @throws {RequiredError}
 * @export
 */ const common_assertParamExists = function(functionName, paramName, paramValue) {
    if (paramValue === null || paramValue === undefined) {
        throw new RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
    }
};
/**
 *
 * @export
 */ const common_setApiKeyToObject = async function(object, keyParamName, configuration) {
    if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === "function" ? await configuration.apiKey(keyParamName) : await configuration.apiKey;
        object[keyParamName] = localVarApiKeyValue;
    }
};
/**
 *
 * @export
 */ const setBasicAuthToObject = function(object, configuration) {
    if (configuration && (configuration.username || configuration.password)) {
        object["auth"] = {
            username: configuration.username,
            password: configuration.password
        };
    }
};
/**
 *
 * @export
 */ const setBearerAuthToObject = async function(object, configuration) {
    if (configuration && configuration.accessToken) {
        const accessToken = typeof configuration.accessToken === "function" ? await configuration.accessToken() : await configuration.accessToken;
        object["Authorization"] = "Bearer " + accessToken;
    }
};
/**
 *
 * @export
 */ const setOAuthToObject = async function(object, name, scopes, configuration) {
    if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue = typeof configuration.accessToken === "function" ? await configuration.accessToken(name, scopes) : await configuration.accessToken;
        object["Authorization"] = "Bearer " + localVarAccessTokenValue;
    }
};
/**
 *
 * @export
 */ const common_setSearchParams = function(url, ...objects) {
    const searchParams = new URLSearchParams(url.search);
    for (const object of objects){
        for(const key in object){
            if (Array.isArray(object[key])) {
                searchParams.delete(key);
                for (const item of object[key]){
                    searchParams.append(key, item);
                }
            } else {
                searchParams.set(key, object[key]);
            }
        }
    }
    url.search = searchParams.toString();
};
/**
 *
 * @export
 */ const serializeDataIfNeeded = function(value, requestOptions, configuration) {
    const nonString = typeof value !== "string";
    const needsSerialization = nonString && configuration && configuration.isJsonMime ? configuration.isJsonMime(requestOptions.headers["Content-Type"]) : nonString;
    return needsSerialization ? JSON.stringify(value !== undefined ? value : {}) : value || "";
};
/**
 *
 * @export
 */ const common_toPathString = function(url) {
    return url.pathname + url.search + url.hash;
};
/**
 *
 * @export
 */ const common_createRequestFunction = function(axiosArgs, globalAxios, BASE_PATH, configuration) {
    return (axios = globalAxios, basePath = BASE_PATH)=>{
        const axiosRequestArgs = {
            ...axiosArgs.options,
            url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + axiosArgs.url
        };
        return axios.request(axiosRequestArgs);
    };
};

;// CONCATENATED MODULE: ./api/api.ts

// Some imports not used depending on template conditions
// @ts-ignore

// @ts-ignore

/**
 * 
 * @export
 * @enum {string}
 */ const AuthMethod = {
    Password: "Password",
    Email: "Email",
    Mobile: "Mobile"
};
/**
 * 
 * @export
 * @enum {string}
 */ const LoginHistoryFilter = {
    All: "All",
    OnlyMe: "OnlyMe"
};
/**
 * 
 * @export
 * @enum {string}
 */ const Role = {
    System: "System",
    User: "User",
    ServiceManager: "ServiceManager",
    Administrator: "Administrator"
};
/**
 * 
 * @export
 * @enum {string}
 */ const ServiceState = {
    Registered: "REGISTERED",
    Pending: "PENDING"
};
/**
 * 
 * @export
 * @enum {string}
 */ const ServiceType = {
    Website: "Website",
    Mobile: "Mobile",
    Desktop: "Desktop"
};
/**
 * AdminApi - axios parameter creator
 * @export
 */ const AdminApiAxiosParamCreator = function(configuration) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ adminApproveServiceManagerRequest: async (userId, options = {})=>{
            // verify required parameter 'userId' is not null or undefined
            common_assertParamExists("adminApproveServiceManagerRequest", "userId", userId);
            const localVarPath = `/api/admin/service-manager-requests/{userId}`.replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "POST",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await common_setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            common_setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: common_toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ adminApproveServiceRequest: async (serviceId, options = {})=>{
            // verify required parameter 'serviceId' is not null or undefined
            common_assertParamExists("adminApproveServiceRequest", "serviceId", serviceId);
            const localVarPath = `/api/admin/service-requests/{serviceId}`.replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "POST",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await common_setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            common_setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: common_toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ adminGetNotificationsCount: async (options = {})=>{
            const localVarPath = `/api/admin/notification-count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "GET",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await common_setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            common_setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: common_toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ adminGetServiceRequests: async (pageNumber, pageSize, options = {})=>{
            const localVarPath = `/api/admin/service-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "GET",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await common_setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (pageNumber !== undefined) {
                localVarQueryParameter["PageNumber"] = pageNumber;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter["PageSize"] = pageSize;
            }
            common_setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: common_toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ adminGetServicesManagerRequests: async (pageNumber, pageSize, options = {})=>{
            const localVarPath = `/api/admin/service-manager-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "GET",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await common_setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (pageNumber !== undefined) {
                localVarQueryParameter["PageNumber"] = pageNumber;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter["PageSize"] = pageSize;
            }
            common_setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: common_toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ adminRemoveServiceManagerRequest: async (userId, options = {})=>{
            // verify required parameter 'userId' is not null or undefined
            common_assertParamExists("adminRemoveServiceManagerRequest", "userId", userId);
            const localVarPath = `/api/admin/service-manager-requests/{userId}`.replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "DELETE",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await common_setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            common_setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: common_toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ adminRemoveServiceRequest: async (serviceId, options = {})=>{
            // verify required parameter 'serviceId' is not null or undefined
            common_assertParamExists("adminRemoveServiceRequest", "serviceId", serviceId);
            const localVarPath = `/api/admin/service-requests/{serviceId}`.replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "DELETE",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await common_setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            common_setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: common_toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};
/**
 * AdminApi - functional programming interface
 * @export
 */ const AdminApiFp = function(configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration);
    return {
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async adminApproveServiceManagerRequest (userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminApproveServiceManagerRequest(userId, options);
            return common_createRequestFunction(localVarAxiosArgs, (external_axios_default()), base_BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async adminApproveServiceRequest (serviceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminApproveServiceRequest(serviceId, options);
            return common_createRequestFunction(localVarAxiosArgs, (external_axios_default()), base_BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async adminGetNotificationsCount (options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminGetNotificationsCount(options);
            return common_createRequestFunction(localVarAxiosArgs, (external_axios_default()), base_BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async adminGetServiceRequests (pageNumber, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminGetServiceRequests(pageNumber, pageSize, options);
            return common_createRequestFunction(localVarAxiosArgs, (external_axios_default()), base_BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async adminGetServicesManagerRequests (pageNumber, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminGetServicesManagerRequests(pageNumber, pageSize, options);
            return common_createRequestFunction(localVarAxiosArgs, (external_axios_default()), base_BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async adminRemoveServiceManagerRequest (userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminRemoveServiceManagerRequest(userId, options);
            return common_createRequestFunction(localVarAxiosArgs, (external_axios_default()), base_BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async adminRemoveServiceRequest (serviceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminRemoveServiceRequest(serviceId, options);
            return common_createRequestFunction(localVarAxiosArgs, (external_axios_default()), base_BASE_PATH, configuration);
        }
    };
};
/**
 * AdminApi - factory interface
 * @export
 */ const AdminApiFactory = function(configuration, basePath, axios) {
    const localVarFp = AdminApiFp(configuration);
    return {
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ adminApproveServiceManagerRequest (userId, options) {
            return localVarFp.adminApproveServiceManagerRequest(userId, options).then((request)=>request(axios, basePath)
            );
        },
        /**
         * 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ adminApproveServiceRequest (serviceId, options) {
            return localVarFp.adminApproveServiceRequest(serviceId, options).then((request)=>request(axios, basePath)
            );
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ adminGetNotificationsCount (options) {
            return localVarFp.adminGetNotificationsCount(options).then((request)=>request(axios, basePath)
            );
        },
        /**
         * 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ adminGetServiceRequests (pageNumber, pageSize, options) {
            return localVarFp.adminGetServiceRequests(pageNumber, pageSize, options).then((request)=>request(axios, basePath)
            );
        },
        /**
         * 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ adminGetServicesManagerRequests (pageNumber, pageSize, options) {
            return localVarFp.adminGetServicesManagerRequests(pageNumber, pageSize, options).then((request)=>request(axios, basePath)
            );
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ adminRemoveServiceManagerRequest (userId, options) {
            return localVarFp.adminRemoveServiceManagerRequest(userId, options).then((request)=>request(axios, basePath)
            );
        },
        /**
         * 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ adminRemoveServiceRequest (serviceId, options) {
            return localVarFp.adminRemoveServiceRequest(serviceId, options).then((request)=>request(axios, basePath)
            );
        }
    };
};
/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */ class AdminApi extends base_BaseAPI {
    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */ adminApproveServiceManagerRequest(userId, options) {
        return AdminApiFp(this.configuration).adminApproveServiceManagerRequest(userId, options).then((request)=>request(this.axios, this.basePath)
        );
    }
    /**
     * 
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */ adminApproveServiceRequest(serviceId, options) {
        return AdminApiFp(this.configuration).adminApproveServiceRequest(serviceId, options).then((request)=>request(this.axios, this.basePath)
        );
    }
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */ adminGetNotificationsCount(options) {
        return AdminApiFp(this.configuration).adminGetNotificationsCount(options).then((request)=>request(this.axios, this.basePath)
        );
    }
    /**
     * 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */ adminGetServiceRequests(pageNumber, pageSize, options) {
        return AdminApiFp(this.configuration).adminGetServiceRequests(pageNumber, pageSize, options).then((request)=>request(this.axios, this.basePath)
        );
    }
    /**
     * 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */ adminGetServicesManagerRequests(pageNumber, pageSize, options) {
        return AdminApiFp(this.configuration).adminGetServicesManagerRequests(pageNumber, pageSize, options).then((request)=>request(this.axios, this.basePath)
        );
    }
    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */ adminRemoveServiceManagerRequest(userId, options) {
        return AdminApiFp(this.configuration).adminRemoveServiceManagerRequest(userId, options).then((request)=>request(this.axios, this.basePath)
        );
    }
    /**
     * 
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */ adminRemoveServiceRequest(serviceId, options) {
        return AdminApiFp(this.configuration).adminRemoveServiceRequest(serviceId, options).then((request)=>request(this.axios, this.basePath)
        );
    }
}
/**
 * AuthApi - axios parameter creator
 * @export
 */ const AuthApiAxiosParamCreator = function(configuration) {
    return {
        /**
         * 
         * @param {AuthorizeCommand} [authorizeCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ authAuthorize: async (authorizeCommand, options = {})=>{
            const localVarPath = `/api/auth/authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "POST",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await common_setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter["Content-Type"] = "application/json";
            common_setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.data = serializeDataIfNeeded(authorizeCommand, localVarRequestOptions, configuration);
            return {
                url: common_toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ authCheck: async (options = {})=>{
            const localVarPath = `/api/auth/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "GET",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await common_setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            common_setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: common_toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * 
         * @param {string} [requestKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ authGetLoginRequestDescription: async (requestKey, options = {})=>{
            const localVarPath = `/api/auth/login-request-desc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "GET",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await common_setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (requestKey !== undefined) {
                localVarQueryParameter["RequestKey"] = requestKey;
            }
            common_setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: common_toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * 
         * @param {LogoutCommand} [logoutCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ authLogout: async (logoutCommand, options = {})=>{
            const localVarPath = `/api/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "POST",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await common_setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter["Content-Type"] = "application/json";
            common_setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.data = serializeDataIfNeeded(logoutCommand, localVarRequestOptions, configuration);
            return {
                url: common_toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * 
         * @param {PasswordLoginCommand} [passwordLoginCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ authPwdLogin: async (passwordLoginCommand, options = {})=>{
            const localVarPath = `/api/auth/pwd-login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "POST",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await common_setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter["Content-Type"] = "application/json";
            common_setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.data = serializeDataIfNeeded(passwordLoginCommand, localVarRequestOptions, configuration);
            return {
                url: common_toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ authRefreshToken: async (options = {})=>{
            const localVarPath = `/api/auth/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "POST",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await common_setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            common_setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: common_toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * 
         * @param {RegisterServiceManagerCommand} [registerServiceManagerCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ authRegisterManager: async (registerServiceManagerCommand, options = {})=>{
            const localVarPath = `/api/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "POST",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await common_setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter["Content-Type"] = "application/json";
            common_setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.data = serializeDataIfNeeded(registerServiceManagerCommand, localVarRequestOptions, configuration);
            return {
                url: common_toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * 
         * @param {TokenCommand} [tokenCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ authToken: async (tokenCommand, options = {})=>{
            const localVarPath = `/api/auth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "POST",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await common_setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter["Content-Type"] = "application/json";
            common_setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.data = serializeDataIfNeeded(tokenCommand, localVarRequestOptions, configuration);
            return {
                url: common_toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * 
         * @param {VerifyLogoutCommand} [verifyLogoutCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ authVerifyLogout: async (verifyLogoutCommand, options = {})=>{
            const localVarPath = `/api/auth/verify-logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "POST",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await common_setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter["Content-Type"] = "application/json";
            common_setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.data = serializeDataIfNeeded(verifyLogoutCommand, localVarRequestOptions, configuration);
            return {
                url: common_toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};
/**
 * AuthApi - functional programming interface
 * @export
 */ const AuthApiFp = function(configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration);
    return {
        /**
         * 
         * @param {AuthorizeCommand} [authorizeCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async authAuthorize (authorizeCommand, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authAuthorize(authorizeCommand, options);
            return common_createRequestFunction(localVarAxiosArgs, (external_axios_default()), base_BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async authCheck (options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authCheck(options);
            return common_createRequestFunction(localVarAxiosArgs, (external_axios_default()), base_BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [requestKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async authGetLoginRequestDescription (requestKey, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authGetLoginRequestDescription(requestKey, options);
            return common_createRequestFunction(localVarAxiosArgs, (external_axios_default()), base_BASE_PATH, configuration);
        },
        /**
         * 
         * @param {LogoutCommand} [logoutCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async authLogout (logoutCommand, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogout(logoutCommand, options);
            return common_createRequestFunction(localVarAxiosArgs, (external_axios_default()), base_BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PasswordLoginCommand} [passwordLoginCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async authPwdLogin (passwordLoginCommand, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authPwdLogin(passwordLoginCommand, options);
            return common_createRequestFunction(localVarAxiosArgs, (external_axios_default()), base_BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async authRefreshToken (options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRefreshToken(options);
            return common_createRequestFunction(localVarAxiosArgs, (external_axios_default()), base_BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RegisterServiceManagerCommand} [registerServiceManagerCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async authRegisterManager (registerServiceManagerCommand, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRegisterManager(registerServiceManagerCommand, options);
            return common_createRequestFunction(localVarAxiosArgs, (external_axios_default()), base_BASE_PATH, configuration);
        },
        /**
         * 
         * @param {TokenCommand} [tokenCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async authToken (tokenCommand, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authToken(tokenCommand, options);
            return common_createRequestFunction(localVarAxiosArgs, (external_axios_default()), base_BASE_PATH, configuration);
        },
        /**
         * 
         * @param {VerifyLogoutCommand} [verifyLogoutCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async authVerifyLogout (verifyLogoutCommand, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authVerifyLogout(verifyLogoutCommand, options);
            return common_createRequestFunction(localVarAxiosArgs, (external_axios_default()), base_BASE_PATH, configuration);
        }
    };
};
/**
 * AuthApi - factory interface
 * @export
 */ const AuthApiFactory = function(configuration, basePath, axios) {
    const localVarFp = AuthApiFp(configuration);
    return {
        /**
         * 
         * @param {AuthorizeCommand} [authorizeCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ authAuthorize (authorizeCommand, options) {
            return localVarFp.authAuthorize(authorizeCommand, options).then((request)=>request(axios, basePath)
            );
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ authCheck (options) {
            return localVarFp.authCheck(options).then((request)=>request(axios, basePath)
            );
        },
        /**
         * 
         * @param {string} [requestKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ authGetLoginRequestDescription (requestKey, options) {
            return localVarFp.authGetLoginRequestDescription(requestKey, options).then((request)=>request(axios, basePath)
            );
        },
        /**
         * 
         * @param {LogoutCommand} [logoutCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ authLogout (logoutCommand, options) {
            return localVarFp.authLogout(logoutCommand, options).then((request)=>request(axios, basePath)
            );
        },
        /**
         * 
         * @param {PasswordLoginCommand} [passwordLoginCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ authPwdLogin (passwordLoginCommand, options) {
            return localVarFp.authPwdLogin(passwordLoginCommand, options).then((request)=>request(axios, basePath)
            );
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ authRefreshToken (options) {
            return localVarFp.authRefreshToken(options).then((request)=>request(axios, basePath)
            );
        },
        /**
         * 
         * @param {RegisterServiceManagerCommand} [registerServiceManagerCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ authRegisterManager (registerServiceManagerCommand, options) {
            return localVarFp.authRegisterManager(registerServiceManagerCommand, options).then((request)=>request(axios, basePath)
            );
        },
        /**
         * 
         * @param {TokenCommand} [tokenCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ authToken (tokenCommand, options) {
            return localVarFp.authToken(tokenCommand, options).then((request)=>request(axios, basePath)
            );
        },
        /**
         * 
         * @param {VerifyLogoutCommand} [verifyLogoutCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ authVerifyLogout (verifyLogoutCommand, options) {
            return localVarFp.authVerifyLogout(verifyLogoutCommand, options).then((request)=>request(axios, basePath)
            );
        }
    };
};
/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */ class AuthApi extends base_BaseAPI {
    /**
     * 
     * @param {AuthorizeCommand} [authorizeCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */ authAuthorize(authorizeCommand, options) {
        return AuthApiFp(this.configuration).authAuthorize(authorizeCommand, options).then((request)=>request(this.axios, this.basePath)
        );
    }
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */ authCheck(options) {
        return AuthApiFp(this.configuration).authCheck(options).then((request)=>request(this.axios, this.basePath)
        );
    }
    /**
     * 
     * @param {string} [requestKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */ authGetLoginRequestDescription(requestKey, options) {
        return AuthApiFp(this.configuration).authGetLoginRequestDescription(requestKey, options).then((request)=>request(this.axios, this.basePath)
        );
    }
    /**
     * 
     * @param {LogoutCommand} [logoutCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */ authLogout(logoutCommand, options) {
        return AuthApiFp(this.configuration).authLogout(logoutCommand, options).then((request)=>request(this.axios, this.basePath)
        );
    }
    /**
     * 
     * @param {PasswordLoginCommand} [passwordLoginCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */ authPwdLogin(passwordLoginCommand, options) {
        return AuthApiFp(this.configuration).authPwdLogin(passwordLoginCommand, options).then((request)=>request(this.axios, this.basePath)
        );
    }
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */ authRefreshToken(options) {
        return AuthApiFp(this.configuration).authRefreshToken(options).then((request)=>request(this.axios, this.basePath)
        );
    }
    /**
     * 
     * @param {RegisterServiceManagerCommand} [registerServiceManagerCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */ authRegisterManager(registerServiceManagerCommand, options) {
        return AuthApiFp(this.configuration).authRegisterManager(registerServiceManagerCommand, options).then((request)=>request(this.axios, this.basePath)
        );
    }
    /**
     * 
     * @param {TokenCommand} [tokenCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */ authToken(tokenCommand, options) {
        return AuthApiFp(this.configuration).authToken(tokenCommand, options).then((request)=>request(this.axios, this.basePath)
        );
    }
    /**
     * 
     * @param {VerifyLogoutCommand} [verifyLogoutCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */ authVerifyLogout(verifyLogoutCommand, options) {
        return AuthApiFp(this.configuration).authVerifyLogout(verifyLogoutCommand, options).then((request)=>request(this.axios, this.basePath)
        );
    }
}
/**
 * NotificationsApi - axios parameter creator
 * @export
 */ const NotificationsApiAxiosParamCreator = function(configuration) {
    return {
        /**
         * 
         * @param {string} subId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ notificationsGetServerSentEvent: async (subId, options = {})=>{
            // verify required parameter 'subId' is not null or undefined
            assertParamExists("notificationsGetServerSentEvent", "subId", subId);
            const localVarPath = `/api/notifications/{subId}`.replace(`{${"subId"}}`, encodeURIComponent(String(subId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "GET",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};
/**
 * NotificationsApi - functional programming interface
 * @export
 */ const NotificationsApiFp = function(configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration);
    return {
        /**
         * 
         * @param {string} subId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async notificationsGetServerSentEvent (subId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsGetServerSentEvent(subId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        }
    };
};
/**
 * NotificationsApi - factory interface
 * @export
 */ const NotificationsApiFactory = function(configuration, basePath, axios) {
    const localVarFp = NotificationsApiFp(configuration);
    return {
        /**
         * 
         * @param {string} subId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ notificationsGetServerSentEvent (subId, options) {
            return localVarFp.notificationsGetServerSentEvent(subId, options).then((request)=>request(axios, basePath)
            );
        }
    };
};
/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */ class NotificationsApi extends (/* unused pure expression or super */ null && (BaseAPI)) {
    /**
     * 
     * @param {string} subId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */ notificationsGetServerSentEvent(subId, options) {
        return NotificationsApiFp(this.configuration).notificationsGetServerSentEvent(subId, options).then((request)=>request(this.axios, this.basePath)
        );
    }
}
/**
 * ServicesApi - axios parameter creator
 * @export
 */ const ServicesApiAxiosParamCreator = function(configuration) {
    return {
        /**
         * 
         * @param {string} [serviceId] 
         * @param {LoginHistoryFilter} [filter] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ servicesGetLoginHistory: async (serviceId, filter, pageNumber, pageSize, options = {})=>{
            const localVarPath = `/api/user/services/login-history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "GET",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await common_setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (serviceId !== undefined) {
                localVarQueryParameter["ServiceId"] = serviceId;
            }
            if (filter !== undefined) {
                localVarQueryParameter["Filter"] = filter;
            }
            if (pageNumber !== undefined) {
                localVarQueryParameter["PageNumber"] = pageNumber;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter["PageSize"] = pageSize;
            }
            common_setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: common_toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ servicesGetServiceDetail: async (serviceId, options = {})=>{
            // verify required parameter 'serviceId' is not null or undefined
            common_assertParamExists("servicesGetServiceDetail", "serviceId", serviceId);
            const localVarPath = `/api/user/services/{serviceId}`.replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "GET",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await common_setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            common_setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: common_toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * 
         * @param {string} [searchQuery] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ servicesGetServices: async (searchQuery, pageNumber, pageSize, options = {})=>{
            const localVarPath = `/api/user/services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "GET",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await common_setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (searchQuery !== undefined) {
                localVarQueryParameter["SearchQuery"] = searchQuery;
            }
            if (pageNumber !== undefined) {
                localVarQueryParameter["PageNumber"] = pageNumber;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter["PageSize"] = pageSize;
            }
            common_setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: common_toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};
/**
 * ServicesApi - functional programming interface
 * @export
 */ const ServicesApiFp = function(configuration) {
    const localVarAxiosParamCreator = ServicesApiAxiosParamCreator(configuration);
    return {
        /**
         * 
         * @param {string} [serviceId] 
         * @param {LoginHistoryFilter} [filter] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async servicesGetLoginHistory (serviceId, filter, pageNumber, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesGetLoginHistory(serviceId, filter, pageNumber, pageSize, options);
            return common_createRequestFunction(localVarAxiosArgs, (external_axios_default()), base_BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async servicesGetServiceDetail (serviceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesGetServiceDetail(serviceId, options);
            return common_createRequestFunction(localVarAxiosArgs, (external_axios_default()), base_BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [searchQuery] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async servicesGetServices (searchQuery, pageNumber, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesGetServices(searchQuery, pageNumber, pageSize, options);
            return common_createRequestFunction(localVarAxiosArgs, (external_axios_default()), base_BASE_PATH, configuration);
        }
    };
};
/**
 * ServicesApi - factory interface
 * @export
 */ const ServicesApiFactory = function(configuration, basePath, axios) {
    const localVarFp = ServicesApiFp(configuration);
    return {
        /**
         * 
         * @param {string} [serviceId] 
         * @param {LoginHistoryFilter} [filter] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ servicesGetLoginHistory (serviceId, filter, pageNumber, pageSize, options) {
            return localVarFp.servicesGetLoginHistory(serviceId, filter, pageNumber, pageSize, options).then((request)=>request(axios, basePath)
            );
        },
        /**
         * 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ servicesGetServiceDetail (serviceId, options) {
            return localVarFp.servicesGetServiceDetail(serviceId, options).then((request)=>request(axios, basePath)
            );
        },
        /**
         * 
         * @param {string} [searchQuery] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ servicesGetServices (searchQuery, pageNumber, pageSize, options) {
            return localVarFp.servicesGetServices(searchQuery, pageNumber, pageSize, options).then((request)=>request(axios, basePath)
            );
        }
    };
};
/**
 * ServicesApi - object-oriented interface
 * @export
 * @class ServicesApi
 * @extends {BaseAPI}
 */ class ServicesApi extends base_BaseAPI {
    /**
     * 
     * @param {string} [serviceId] 
     * @param {LoginHistoryFilter} [filter] 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */ servicesGetLoginHistory(serviceId, filter, pageNumber, pageSize, options) {
        return ServicesApiFp(this.configuration).servicesGetLoginHistory(serviceId, filter, pageNumber, pageSize, options).then((request)=>request(this.axios, this.basePath)
        );
    }
    /**
     * 
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */ servicesGetServiceDetail(serviceId, options) {
        return ServicesApiFp(this.configuration).servicesGetServiceDetail(serviceId, options).then((request)=>request(this.axios, this.basePath)
        );
    }
    /**
     * 
     * @param {string} [searchQuery] 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */ servicesGetServices(searchQuery, pageNumber, pageSize, options) {
        return ServicesApiFp(this.configuration).servicesGetServices(searchQuery, pageNumber, pageSize, options).then((request)=>request(this.axios, this.basePath)
        );
    }
}
/**
 * ServicesManagerApi - axios parameter creator
 * @export
 */ const ServicesManagerApiAxiosParamCreator = function(configuration) {
    return {
        /**
         * 
         * @param {CreateServiceCommand} [createServiceCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ servicesManagerCreateService: async (createServiceCommand, options = {})=>{
            const localVarPath = `/api/manager/services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "POST",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await common_setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter["Content-Type"] = "application/json";
            common_setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.data = serializeDataIfNeeded(createServiceCommand, localVarRequestOptions, configuration);
            return {
                url: common_toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ servicesManagerDeleteService: async (serviceId, options = {})=>{
            // verify required parameter 'serviceId' is not null or undefined
            common_assertParamExists("servicesManagerDeleteService", "serviceId", serviceId);
            const localVarPath = `/api/manager/services/{serviceId}`.replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "DELETE",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await common_setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            common_setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: common_toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ servicesManagerGetServiceDetail: async (serviceId, options = {})=>{
            // verify required parameter 'serviceId' is not null or undefined
            common_assertParamExists("servicesManagerGetServiceDetail", "serviceId", serviceId);
            const localVarPath = `/api/manager/services/{serviceId}`.replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "GET",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await common_setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            common_setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: common_toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * 
         * @param {string} [searchQuery] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ servicesManagerGetServices: async (searchQuery, pageNumber, pageSize, options = {})=>{
            const localVarPath = `/api/manager/services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "GET",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await common_setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (searchQuery !== undefined) {
                localVarQueryParameter["SearchQuery"] = searchQuery;
            }
            if (pageNumber !== undefined) {
                localVarQueryParameter["PageNumber"] = pageNumber;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter["PageSize"] = pageSize;
            }
            common_setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: common_toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * 
         * @param {UpdateServiceCommand} [updateServiceCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ servicesManagerUpdateService: async (updateServiceCommand, options = {})=>{
            const localVarPath = `/api/manager/services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "PUT",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await common_setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter["Content-Type"] = "application/json";
            common_setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.data = serializeDataIfNeeded(updateServiceCommand, localVarRequestOptions, configuration);
            return {
                url: common_toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};
/**
 * ServicesManagerApi - functional programming interface
 * @export
 */ const ServicesManagerApiFp = function(configuration) {
    const localVarAxiosParamCreator = ServicesManagerApiAxiosParamCreator(configuration);
    return {
        /**
         * 
         * @param {CreateServiceCommand} [createServiceCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async servicesManagerCreateService (createServiceCommand, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesManagerCreateService(createServiceCommand, options);
            return common_createRequestFunction(localVarAxiosArgs, (external_axios_default()), base_BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async servicesManagerDeleteService (serviceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesManagerDeleteService(serviceId, options);
            return common_createRequestFunction(localVarAxiosArgs, (external_axios_default()), base_BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async servicesManagerGetServiceDetail (serviceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesManagerGetServiceDetail(serviceId, options);
            return common_createRequestFunction(localVarAxiosArgs, (external_axios_default()), base_BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [searchQuery] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async servicesManagerGetServices (searchQuery, pageNumber, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesManagerGetServices(searchQuery, pageNumber, pageSize, options);
            return common_createRequestFunction(localVarAxiosArgs, (external_axios_default()), base_BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateServiceCommand} [updateServiceCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async servicesManagerUpdateService (updateServiceCommand, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesManagerUpdateService(updateServiceCommand, options);
            return common_createRequestFunction(localVarAxiosArgs, (external_axios_default()), base_BASE_PATH, configuration);
        }
    };
};
/**
 * ServicesManagerApi - factory interface
 * @export
 */ const ServicesManagerApiFactory = function(configuration, basePath, axios) {
    const localVarFp = ServicesManagerApiFp(configuration);
    return {
        /**
         * 
         * @param {CreateServiceCommand} [createServiceCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ servicesManagerCreateService (createServiceCommand, options) {
            return localVarFp.servicesManagerCreateService(createServiceCommand, options).then((request)=>request(axios, basePath)
            );
        },
        /**
         * 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ servicesManagerDeleteService (serviceId, options) {
            return localVarFp.servicesManagerDeleteService(serviceId, options).then((request)=>request(axios, basePath)
            );
        },
        /**
         * 
         * @param {string} serviceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ servicesManagerGetServiceDetail (serviceId, options) {
            return localVarFp.servicesManagerGetServiceDetail(serviceId, options).then((request)=>request(axios, basePath)
            );
        },
        /**
         * 
         * @param {string} [searchQuery] 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ servicesManagerGetServices (searchQuery, pageNumber, pageSize, options) {
            return localVarFp.servicesManagerGetServices(searchQuery, pageNumber, pageSize, options).then((request)=>request(axios, basePath)
            );
        },
        /**
         * 
         * @param {UpdateServiceCommand} [updateServiceCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ servicesManagerUpdateService (updateServiceCommand, options) {
            return localVarFp.servicesManagerUpdateService(updateServiceCommand, options).then((request)=>request(axios, basePath)
            );
        }
    };
};
/**
 * ServicesManagerApi - object-oriented interface
 * @export
 * @class ServicesManagerApi
 * @extends {BaseAPI}
 */ class ServicesManagerApi extends base_BaseAPI {
    /**
     * 
     * @param {CreateServiceCommand} [createServiceCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesManagerApi
     */ servicesManagerCreateService(createServiceCommand, options) {
        return ServicesManagerApiFp(this.configuration).servicesManagerCreateService(createServiceCommand, options).then((request)=>request(this.axios, this.basePath)
        );
    }
    /**
     * 
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesManagerApi
     */ servicesManagerDeleteService(serviceId, options) {
        return ServicesManagerApiFp(this.configuration).servicesManagerDeleteService(serviceId, options).then((request)=>request(this.axios, this.basePath)
        );
    }
    /**
     * 
     * @param {string} serviceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesManagerApi
     */ servicesManagerGetServiceDetail(serviceId, options) {
        return ServicesManagerApiFp(this.configuration).servicesManagerGetServiceDetail(serviceId, options).then((request)=>request(this.axios, this.basePath)
        );
    }
    /**
     * 
     * @param {string} [searchQuery] 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesManagerApi
     */ servicesManagerGetServices(searchQuery, pageNumber, pageSize, options) {
        return ServicesManagerApiFp(this.configuration).servicesManagerGetServices(searchQuery, pageNumber, pageSize, options).then((request)=>request(this.axios, this.basePath)
        );
    }
    /**
     * 
     * @param {UpdateServiceCommand} [updateServiceCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesManagerApi
     */ servicesManagerUpdateService(updateServiceCommand, options) {
        return ServicesManagerApiFp(this.configuration).servicesManagerUpdateService(updateServiceCommand, options).then((request)=>request(this.axios, this.basePath)
        );
    }
}
/**
 * UserApi - axios parameter creator
 * @export
 */ const UserApiAxiosParamCreator = function(configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ userGetProfile: async (options = {})=>{
            const localVarPath = `/api/user/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "GET",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await common_setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            common_setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: common_toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * 
         * @param {UpdateSettingsCommand} [updateSettingsCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ userUpdateSettings: async (updateSettingsCommand, options = {})=>{
            const localVarPath = `/api/user/update-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "PATCH",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await common_setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter["Content-Type"] = "application/json";
            common_setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.data = serializeDataIfNeeded(updateSettingsCommand, localVarRequestOptions, configuration);
            return {
                url: common_toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};
/**
 * UserApi - functional programming interface
 * @export
 */ const UserApiFp = function(configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async userGetProfile (options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetProfile(options);
            return common_createRequestFunction(localVarAxiosArgs, (external_axios_default()), base_BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateSettingsCommand} [updateSettingsCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async userUpdateSettings (updateSettingsCommand, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUpdateSettings(updateSettingsCommand, options);
            return common_createRequestFunction(localVarAxiosArgs, (external_axios_default()), base_BASE_PATH, configuration);
        }
    };
};
/**
 * UserApi - factory interface
 * @export
 */ const UserApiFactory = function(configuration, basePath, axios) {
    const localVarFp = UserApiFp(configuration);
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ userGetProfile (options) {
            return localVarFp.userGetProfile(options).then((request)=>request(axios, basePath)
            );
        },
        /**
         * 
         * @param {UpdateSettingsCommand} [updateSettingsCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ userUpdateSettings (updateSettingsCommand, options) {
            return localVarFp.userUpdateSettings(updateSettingsCommand, options).then((request)=>request(axios, basePath)
            );
        }
    };
};
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */ class UserApi extends base_BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */ userGetProfile(options) {
        return UserApiFp(this.configuration).userGetProfile(options).then((request)=>request(this.axios, this.basePath)
        );
    }
    /**
     * 
     * @param {UpdateSettingsCommand} [updateSettingsCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */ userUpdateSettings(updateSettingsCommand, options) {
        return UserApiFp(this.configuration).userUpdateSettings(updateSettingsCommand, options).then((request)=>request(this.axios, this.basePath)
        );
    }
}
/**
 * UsersApi - axios parameter creator
 * @export
 */ const UsersApiAxiosParamCreator = function(configuration) {
    return {
        /**
         * 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ usersGetUsers: async (pageNumber, pageSize, options = {})=>{
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "GET",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (pageNumber !== undefined) {
                localVarQueryParameter["PageNumber"] = pageNumber;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter["PageSize"] = pageSize;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};
/**
 * UsersApi - functional programming interface
 * @export
 */ const UsersApiFp = function(configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
    return {
        /**
         * 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async usersGetUsers (pageNumber, pageSize, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGetUsers(pageNumber, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        }
    };
};
/**
 * UsersApi - factory interface
 * @export
 */ const UsersApiFactory = function(configuration, basePath, axios) {
    const localVarFp = UsersApiFp(configuration);
    return {
        /**
         * 
         * @param {number} [pageNumber] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ usersGetUsers (pageNumber, pageSize, options) {
            return localVarFp.usersGetUsers(pageNumber, pageSize, options).then((request)=>request(axios, basePath)
            );
        }
    };
};
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */ class UsersApi extends (/* unused pure expression or super */ null && (BaseAPI)) {
    /**
     * 
     * @param {number} [pageNumber] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */ usersGetUsers(pageNumber, pageSize, options) {
        return UsersApiFp(this.configuration).usersGetUsers(pageNumber, pageSize, options).then((request)=>request(this.axios, this.basePath)
        );
    }
}


/***/ }),

/***/ 1534:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Hi": () => (/* reexport safe */ _api__WEBPACK_IMPORTED_MODULE_0__.Hi),
/* harmony export */   "R0": () => (/* reexport safe */ _api__WEBPACK_IMPORTED_MODULE_0__.R0),
/* harmony export */   "UW": () => (/* reexport safe */ _api__WEBPACK_IMPORTED_MODULE_0__.UW),
/* harmony export */   "Wj": () => (/* reexport safe */ _api__WEBPACK_IMPORTED_MODULE_0__.Wj),
/* harmony export */   "uU": () => (/* reexport safe */ _api__WEBPACK_IMPORTED_MODULE_0__.uU),
/* harmony export */   "x0": () => (/* reexport safe */ _api__WEBPACK_IMPORTED_MODULE_0__.x0),
/* harmony export */   "x3": () => (/* reexport safe */ _api__WEBPACK_IMPORTED_MODULE_0__.x3),
/* harmony export */   "xq": () => (/* reexport safe */ _api__WEBPACK_IMPORTED_MODULE_0__.xq),
/* harmony export */   "z9": () => (/* reexport safe */ _api__WEBPACK_IMPORTED_MODULE_0__.z9)
/* harmony export */ });
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2855);
/* tslint:disable */ /* eslint-disable */ /**
 * SSO.Api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ 



/***/ })

};
;